### **Лекция 1: Введение в C#. Базовый синтаксис, типы данных, управляющие конструкции**
**Цель:** Дать студентам необходимый минимум C# для написания простых алгоритмов.
**Содержание:**
1.  **Введение:** Кратко о платформе .NET и языке C#. Среды разработки (Visual Studio, Rider, VS Code). Структура простой консольной программы.
2.  **Типы данных и переменные:**
    *   Примитивные типы (`int`, `double`, `bool`, `char`), `string`. Ключевое слово `var`.
    *   **Приведение типов:** явное (`(int)doubleValue`) и неявное (например, `int` → `long`).
    *   **Конвертация данных:**
        *   Класс `Convert`: `Convert.ToInt32()`, `ToString()`.
        *   Методы `Parse()` и `TryParse()`: принципиальная разница (исключение vs безопасная попытка). Пример: `int.Parse("123")` и `int.TryParse("abc", out result)`.
3.  **Базовые операции:** арифметические, сравнения, логические, тернарный оператор (`? :`).
4.  **Управляющие конструкции:**
    *   Условные операторы: `if-else`, `if-else if`.
    *   **Оператор выбора `switch`:** классический синтаксис (с `break`) и **новый синтаксис** (начиная с C# 8.0): switch-expressions с возвратом значения, сопоставление паттернов (pattern matching). Пример:
    *   **Циклы:** `for`, `while`, `do-while`, `foreach`.
    *   **Ключевые слова `break` и `continue`:** прерывание цикла (`break`) и переход к следующей итерации (`continue`). Примеры использования.
5.  **Ввод-вывод в консоли:** `Console.ReadLine()`, `Console.WriteLine()`, `Console.Write()`.
6.  **Практический пример:** Написание программы, использующей условия, циклы, `TryParse` для безопасного ввода и новый `switch` для классификации данных.

### **Лекция 2: C#: Методы, массивы, основы ООП. Значимые и ссылочные типы. String**
**Цель:** Научить студентов организовывать код, работать с коллекциями данных, понимать разницу в хранении данных в памяти и эффективно работать с текстом.
**Содержание:**
1.  **Методы (функции):**
    *   Объявление, параметры, возвращаемые значения. Перегрузка методов.
    *   Параметры, передаваемые по значению и по ссылке (`ref`, `out`). Ключевое слово `in`.
    *   Понятие стека вызовов.
2.  **Массивы:** одномерные и многомерные (зубчатые/jagged и прямоугольные/rectangular). Объявление, инициализация, обход.
3.  **Критически важная теория: Значимые (Value) и ссылочные (Reference) типы.**
    *   **Значимые типы:** `int`, `double`, `bool`, `char`, `struct`. Хранятся в стеке (stack). Присваивание копирует значение.
    *   **Ссылочные типы:** `string`, `Array`, `class`, `interface`. Хранятся в управляемой куче (heap). Переменная содержит ссылку. Присваивание копирует ссылку.
    *   **Пример-иллюстрация:** изменение поля объекта, переданного в метод.
    *   Ключевое слово `null` для ссылочных типов. Nullable Value Types (`int?`).
4.  **Работа со строками (тип `string`):**
    *   `string` как **неизменяемый (immutable)** ссылочный тип. Последствия неизменяемости для производительности.
    *   Основные операции: конкатенация (`+`, `$"{a} text"`), сравнение (`==`, `Equals`, `String.Compare`), основные методы (`Length`, `Substring`, `IndexOf`, `Split`, `Join`, `Replace`, `ToUpper/ToLower`).
    *   **Введение в `StringBuilder` (класс `System.Text.StringBuilder`):**
        *   Зачем нужен? Проблема множественной конкатенации строк в цикле (создание множества объектов).
        *   Основные методы: `Append()`, `AppendLine()`, `Insert()`, `Remove()`, `Clear()`, `ToString()`.
        *   **Сравнение производительности:** наглядный пример конкатенации 10000 строк через `string` и через `StringBuilder`.
5.  **Введение в ООП (минимально необходимое для алгоритмов):**
    *   Класс как новый ссылочный тип данных. Объект — экземпляр класса.
    *   Поля (данные) и методы (поведение). Конструкторы.
    *   Модификаторы доступа (`public`, `private`).
6.  **Практический пример:** Создание простого класса (например, `Student`), демонстрация работы со списком студентов и формирование отчета о них с использованием `StringBuilder`.

### **Лекция 3: Анализ сложности алгоритмов. Простые структуры данных: списки**
**Цель:** Заложить фундаментальную основу для оценки алгоритмов и ввести первую динамическую структуру данных.
**Содержание:**
1.  **Анализ алгоритмов:** время работы и потребление памяти. Практическая значимость.
2.  **Асимптотическая сложность (нотация О-большое):** `O(1)`, `O(log n)`, `O(n)`, `O(n log n)`, `O(n^2)`, `O(2^n)`. Примеры для каждого случая.
3.  **Списки (`List<T>`):**
    *   Понятие динамического массива. Внутреннее устройство `List<T>` (массив под капотом, увеличение `Capacity`).
    *   Основные операции: `Add`, `Insert`, `Remove`, `RemoveAt`, доступ по индексу, `Contains`. **Анализ их амортизированной сложности.**
    *   Отличие от классического массива (`T[]`). Когда что использовать.
4.  **Сравнение структур на практике:** Массив vs `List<T>` vs `StringBuilder` (как специализированная коллекция для символов).
5.  **Практический пример:** Реализация алгоритма, использующего `List<T>` (например, фильтрация коллекции), и анализ его сложности.

### **Лекция 4: Алгоритмы сортировки и поиска**
**Цель:** Углубиться в классические алгоритмы, понимать их внутреннее устройство и области применения.
**Содержание:**
1.  **Сортировка:** важность и области применения. Связь с бинарным поиском.
2.  **Быстрая сортировка (Quicksort):** принцип "разделяй и властвуй", выбор опорного элемента, алгоритм Хоара. Средняя (`O(n log n)`) и худшая (`O(n^2)`) сложность.
3.  **Сортировка слиянием (Mergesort):** принцип "разделяй и властвуй", устойчивость. Сложность `O(n log n)` и необходимость дополнительной памяти `O(n)`.
4.  **Сравнение сортировок:** когда какую использовать. Встроенная сортировка в C# (`Array.Sort()`, `List<T>.Sort()`), основанная на **Introsort** (гибрид Quicksort, Heapsort и Insertion sort).
5.  **Алгоритмы поиска:**
    *   Линейный поиск (`O(n)`).
    *   **Бинарный поиск:** условие применения (отсортированная коллекция), алгоритм, сложность `O(log n)`. Методы `Array.BinarySearch()` и `List<T>.BinarySearch()`.
6.  **Практический пример:** Реализация сортировки и бинарного поиска для набора данных. Обсуждение, почему хеш-таблица (`Dictionary`) может быть лучше для поиска по ключу, если не нужен порядок.

### **Лекция 5: Стеки, очереди, хеш-таблицы**
**Цель:** Изучить абстрактные типы данных с принципом LIFO/FIFO и структуру данных с быстрым поиском (`O(1)`).
**Содержание:**
1.  **Абстрактные типы данных (АТД):** понятие интерфейса структуры (что можно делать, а не как реализовано).
2.  **Стек (АТД):** принцип LIFO (Last-In-First-Out). Класс `Stack<T>` в C#. Основные операции: `Push`, `Pop`, `Peek`. Примеры использования: отмена операций, обход в глубину (DFS), проверка корректности скобочной последовательности.
3.  **Очередь (АТД):** принцип FIFO (First-In-First-Out). Класс `Queue<T>` в C#. Основные операции: `Enqueue`, `Dequeue`, `Peek`. Примеры использования: очередь задач, обход в ширину (BFS), кеширование.
4.  **Хеш-таблица:**
    *   Концепция: ключ → значение. Хеш-функция, разрешение коллизий (кратко, метод цепочек).
    *   Классы `Dictionary<TKey, TValue>` (словарь) и `HashSet<T>` (множество) в C#. Сходства и различия.
    *   **Сложность операций:** в среднем `O(1)` для поиска, вставки, удаления. **Контракт `GetHashCode()` и `Equals()`:** почему это важно для пользовательских типов-ключей.
5.  **Практический пример:** Решение задачи на подсчет частот элементов с помощью `Dictionary` и задачи на проверку уникальности с помощью `HashSet`.

### **Лекция 6: Деревья. Бинарные деревья поиска**
**Цель:** Ввести иерархическую структуру данных, которая организует данные в порядке, позволяющем эффективно выполнять поиск, вставку и удаление.
**Содержание:**
1.  **Деревья:** основные понятия (корень, узел, лист, ребро, глубина, высота, предок/потомок).
2.  **Бинарное дерево поиска (BST):** определение и ключевое свойство: для каждого узла `X` все ключи в левом поддереве меньше ключа `X`, а в правом — больше.
3.  **Основные операции в BST:**
    *   **Поиск, Вставка:** рекурсивные и итеративные алгоритмы.
    *   **Удаление:** три случая (узел — лист; узел имеет одного потомка; узел имеет двух потомков — поиск наименьшего в правом поддереве).
    *   Сложность операций: в среднем `O(log n)`, в худшем (вырожденное дерево) `O(n)`.
4.  **Обходы дерева (Traversals):**
    *   **В глубину (DFS):** прямой/pre-order (`корень → лево → право`), симметричный/in-order (`лево → корень → право` — дает отсортированную последовательность для BST!), обратный/post-order (`лево → право → корень`).
    *   **В ширину (BFS):** level-order (использует очередь).
5.  **Практический пример:** Реализация простого BST для `int` с операциями вставки и симметричного обхода. Сравнение с `SortedSet<T>` из .NET.

### **Лекция 7: Графы: представление, обход, алгоритмы**
**Цель:** Познакомить с наиболее общей структурой данных для моделирования связей и основными алгоритмами на графах.
**Содержание:**
1.  **Графы:** основные понятия (вершины/V, ребра/E), виды (направленные/ненаправленные, взвешенные/невзвешенные).
2.  **Способы представления в памяти:**
    *   **Матрица смежности:** двумерный массив `int[,]`. Плюсы (`O(1)` на проверку ребра) и минусы (`O(V^2)` памяти).
    *   **Список смежности:** массив/список списков (`List<List<int>>` или `Dictionary<int, List<int>>`). Плюсы (экономия памяти для разреженных графов) и минусы.
3.  **Алгоритмы обхода графа (Graph Traversal):**
    *   **Поиск в глубину (DFS):** рекурсивный алгоритм, стековый алгоритм. Применение: поиск цикла, топологическая сортировка.
    *   **Поиск в ширину (BFS):** итеративный алгоритм с очередью. Применение: поиск кратчайшего пути в невзвешенном графе, нахождение расстояний.
4.  **Классические задачи и понятия:** связность графа, компоненты связности, проверка на двудольность.
5.  **Практический пример:** Реализация представления графа списком смежности и написание функции обхода BFS для нахождения расстояния от заданной вершины до всех остальных.

### **Лекция 8: Жадные алгоритмы и динамическое программирование (введение)**
**Цель:** Познакомить с двумя мощными парадигмами разработки алгоритмов для решения оптимизационных задач.
**Содержание:**
1.  **Жадные алгоритмы (Greedy Algorithms):**
    *   Принцип: локально оптимальный выбор на каждом шаге в надежде на глобально оптимальное решение.
    *   Примеры: **Задача о выборе заявок** (максимальное количество непересекающихся интервалов), **Алгоритм Дейкстры** (концепция, без реализации с кучей).
    *   Достоинства (простота, эффективность) и недостатки (не всегда дают оптимальное решение).
2.  **Динамическое программирование (Dynamic Programming, DP):**
    *   Принцип оптимальности Беллмана. Разбиение задачи на перекрывающиеся подзадачи.
    *   **Два основных подхода:**
        *   **Мемоизация (Top-Down):** рекурсия с кешированием результатов (часто с использованием `Dictionary`).
        *   **Восходящее ДП (Bottom-Up):** заполнение таблицы (часто двумерного массива).
3.  **Классические задачи ДП:**
    *   **Числа Фибоначчи** (как простейший пример перекрывающихся подзадач).
    *   **Задача о рюкзаке 0-1** (Knapsack 0-1).
    *   **Наибольшая общая подпоследовательность (LCS).**
4.  **Итог курса:** Связь между структурами данных, алгоритмами и парадигмами. Обзор тем для дальнейшего изучения (сбалансированные деревья AVL/Красно-черные, алгоритмы на графах (Дейкстра, Флойд), строковые алгоритмы).

---

Этот план обеспечивает логичный и прогрессивный путь от основ синтаксиса C# к фундаментальным алгоритмам и структурам данных, подкрепленный практическими примерами и пониманием сложности.
